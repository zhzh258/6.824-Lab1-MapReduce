# Lab 1 - MapReduce 
## How to Run
### Script
```bash
6.824/src/main$ bash my-test.sh
```
Modify NUM_WORKERS to change number of worker

### Manually
```bash
6.824/src/main$ go run mrcoordinator.go pg*.txt
```
In another terminal:
```bash
6.824/src/main$ go build -race -buildmode=plugin ../mrapps/wc.go
6.824/src/main$ go run -race mrworker.go wc.so
```

## Worker.mapById(), Worker.reduceById(): IO and Variables 
### Variables
1. `M` or `reply.M` - Number of Map() tasks. Id = 0, 1, ..., M-1
2. `N` or `reply.N` - Number of Reduce() tasks. Id = 0, 1, ..., N-1
3. `X` or `reply.X` - Map() Id
4. `Y` or `reply.Y` - Reduce() Id

### Files
1. `/main/intermediate/mr-X-Y` - The intermediate file for the Y-th Reduce(), generated by the X-th Map()
- the M `mr-???-Y` files forms the Y-th bucket. **all `thisIsAStrangeWord` falls into the same bucket**
2. `/main/output/mr/mr-output-Y` - The output of the Y-th Reduce()


## Concurrency (This version works with multiple workers! See my-test.sh)
### Data Struct Explained
1. `c.MapState.Tasks[i].Attempt`
- How many times (any) worker has fetched task i and tried to solve it.
2. `GetMaoReply.StartTime` or `PushMapResponse.StartTime`
- The time (on Coordinator) a task was sent to worker.
- It persists when worker is executing doMapById() and will be returned to Coordinator.
	



### Life Cycle of A Worker
```C
while(!map_done){
    GetMap(); // request a Map()
    PushMap(); // response
}
while(!reduce_done){
    GetReduce(); // request a Reduce()
    PushReduce(); // response
}
``` 

### Possible States When Worker is Requesting a Map()
1. Coordinator has a "pending" Map() to allocate.
2. Coordinator doesn't have a "pending" Map() yet. But might have one in the future. (e.g. worker crash / worker timeout)
3. All Map() have been successfully done.

### life Cycle of Coordinator.GetMap()
```C
if(has_map_to_do){
    Map()
    setTimeout()
    return map
} 
if(no_map_to_do){
    Sleep()
    // Zzzzzzzzzzz
    // onWoken:
    if(woken_by_case_a){
        // done
    }
    else if(woken_by_case_b){
        // assign the failed Map() to a blocked worker
    }

}
```
Q: What will wake up the Cond()?
A:
    (a). Cond.Broadcast():
        - All Map() have been done
    (b). Cond.Signal():
        - When another worker returns and in rejected_case_2

### life Cycle of Coordinator.PushMap()
1. `accepted` or `rejected` - whether the Map() **complete** a Map(). i.e. the Map task is done permanently.
2. `if`, `else if`, `else if` - This is because some other workers might process the Map task before it returns a result that is `rejected`
```C
if(accepted){
    if(the_last_task_to_complete){
        // mark allDone
        // Cond.Broadcast() 
    } 
} 
else if(rejected){
    // TODO
}

```


