# Lab 1 - MapReduce 
## How to Run
### bash 1
```bash
nonox@Ubuntu:~/Desktop/project/6.824/src/main$ go run mrcoordinator.go pg*.txt
```
### bash 2
```bash
nonox@Ubuntu:~/Desktop/project/6.824/src/main$ go build -race -buildmode=plugin ../mrapps/wc.go
nonox@Ubuntu:~/Desktop/project/6.824/src/main$ go run -race mrworker.go wc.so
```

## IO and Variables
### Variables
1. `M` or `reply.M` - Number of Map() tasks. Id = 0, 1, ..., M-1
2. `N` or `reply.N` - Number of Reduce() tasks. Id = 0, 1, ..., N-1
3. `X` or `reply.X` - Map() Id
4. `Y` or `reply.Y` - Reduce() Id

### Files
1. `/main/intermediate/mr-X-Y` - The intermediate file for the Y-th Reduce(), generated by the X-th Map()
2. `/main/output/mr/mr-output-Y` - The output of the Y-th Reduce()

## I. Concurrency (single worker)
### Life Cycle of A Worker
```C
while(!map_done){
    GetMap(); // request a Map()
    PushMap(); // response
}
while(!reduce_done){
    GetReduce(); // request a Reduce()
    PushReduce(); // response
}
``` 

### Possible States When Worker is Requesting a Map()
1. Coordinator has a "pending" Map() to allocate.
2. Coordinator doesn't have a "pending" Map() yet. But might have one in the future. (e.g. worker crash / worker timeout)
3. All Map() have been successfully done.

### life Cycle of Coordinator.GetMap()
```C
if(has_pending_map){
    set_timeout_timer()
    return map
} else if(!has_pending_map && !done){
    cond.Wait() // wait until: another_worker_fail || all_map_done
} else if(done){
    return done;
}
```

### life Cycle of Coordinator.PushMap()
```C
switch(res){
    case successful: 
        mark_as_done();
        
    case fail: 
        enqueue_the_failed_map()
}
```

## II. Concurrency (multiple workers)


